# matching_workflow.py - autogenerated template file
from langgraph.graph import StateGraph, END
from langgraph.graph.message import add_messages
from typing import TypedDict, Annotated, List, Dict, Any
import logging

from agents.job_description_agent import JobDescriptionAgent
from agents.resume_agent import ResumeAgent
from agents.matching_agent import MatchingAgent
from models.data_models import ResumeData, JobDescription, MatchingResult, AgentResponse

logger = logging.getLogger(__name__)

class WorkflowState(TypedDict):
    """State for the resume-job matching workflow"""
    messages: Annotated[List[Dict], add_messages]
    resume_file_path: str
    job_descriptions: List[str]
    resume_data: Dict[str, Any]
    job_data: Dict[str, Any]
    matching_results: Dict[str, Any]
    workflow_status: str
    error_message: str

class ResumeJobMatchingWorkflow:
    """LangGraph workflow for resume-job matching process"""
    
    def __init__(self):
        self.resume_agent = ResumeAgent()
        self.job_agent = JobDescriptionAgent()
        self.matching_agent = MatchingAgent()
        self.workflow = self._create_workflow()
    
    def _create_workflow(self) -> StateGraph:
        """Create the LangGraph workflow"""
        
        # Define the workflow graph
        workflow = StateGraph(WorkflowState)
        
        # Add nodes for each step
        workflow.add_node("analyze_resume", self._analyze_resume_node)
        workflow.add_node("analyze_jobs", self._analyze_jobs_node)
        workflow.add_node("match_resume_jobs", self._match_resume_jobs_node)
        workflow.add_node("finalize_results", self._finalize_results_node)
        workflow.add_node("handle_error", self._handle_error_node)
        
        # Define the workflow edges
        workflow.set_entry_point("analyze_resume")
        
        # Add conditional edges
        workflow.add_conditional_edges(
            "analyze_resume",
            self._check_resume_analysis,
            {
                "success": "analyze_jobs",
                "error": "handle_error"
            }
        )
        
        workflow.add_conditional_edges(
            "analyze_jobs",
            self._check_job_analysis,
            {
                "success": "match_resume_jobs",
                "error": "handle_error"
            }
        )
        
        workflow.add_conditional_edges(
            "match_resume_jobs",
            self._check_matching_results,
            {
                "success": "finalize_results",
                "error": "handle_error"
            }
        )
        
        workflow.add_edge("finalize_results", END)
        workflow.add_edge("handle_error", END)
        
        return workflow.compile()
    
    def _analyze_resume_node(self, state: WorkflowState) -> WorkflowState:
        """Node to analyze the resume"""
        try:
            logger.info("Starting resume analysis...")
            
            response = self.resume_agent.analyze_resume(state["resume_file_path"])
            
            if response.success:
                state["resume_data"] = response.data
                state["workflow_status"] = "resume_analyzed"
                state["messages"].append({
                    "role": "system",
                    "content": f"Resume analyzed successfully: {response.message}"
                })
            else:
                state["error_message"] = response.error or response.message
                state["workflow_status"] = "error"
                
        except Exception as e:
            logger.error(f"Error in resume analysis node: {str(e)}")
            state["error_message"] = str(e)
            state["workflow_status"] = "error"
        
        return state
    
    def _analyze_jobs_node(self, state: WorkflowState) -> WorkflowState:
        """Node to analyze job descriptions"""
        try:
            logger.info("Starting job descriptions analysis...")
            
            response = self.job_agent.analyze_job_descriptions(state["job_descriptions"])
            
            if response.success:
                state["job_data"] = response.data
                state["workflow_status"] = "jobs_analyzed"
                state["messages"].append({
                    "role": "system",
                    "content": f"Job descriptions analyzed successfully: {response.message}"
                })
            else:
                state["error_message"] = response.error or response.message
                state["workflow_status"] = "error"
                
        except Exception as e:
            logger.error(f"Error in job analysis node: {str(e)}")
            state["error_message"] = str(e)
            state["workflow_status"] = "error"
        
        return state
    
    def _match_resume_jobs_node(self, state: WorkflowState) -> WorkflowState:
        """Node to match resume with job descriptions"""
        try:
            logger.info("Starting resume-job matching...")
            
            # Convert data back to models
            resume_data = ResumeData(**state["resume_data"])
            job_descriptions = [JobDescription(**job) for job in state["job_data"]["jobs"]]
            
            response = self.matching_agent.match_resume_to_jobs(resume_data, job_descriptions)
            
            if response.success:
                state["matching_results"] = response.data
                state["workflow_status"] = "matching_complete"
                state["messages"].append({
                    "role": "system",
                    "content": f"Matching completed successfully: {response.message}"
                })
            else:
                state["error_message"] = response.error or response.message
                state["workflow_status"] = "error"
                
        except Exception as e:
            logger.error(f"Error in matching node: {str(e)}")
            state["error_message"] = str(e)
            state["workflow_status"] = "error"
        
        return state
    
    def _finalize_results_node(self, state: WorkflowState) -> WorkflowState:
        """Node to finalize and format results"""
        try:
            logger.info("Finalizing results...")
            
            # Add summary message
            matching_result = MatchingResult(**state["matching_results"])
            best_match = matching_result.best_match
            
            if best_match:
                summary = f"""
                🎯 **BEST JOB MATCH FOUND!**
                
                **Top Recommendation:** {best_match.job_title}
                **Company:** {best_match.company or 'Not specified'}
                **Match Score:** {best_match.overall_score:.1%}
                **Ranking:** #{best_match.ranking}
                
                **Why this is a great match:**
                {best_match.recommendation_reason}
                
                **Skills Matched:** {len([s for s in best_match.matched_skills if s.is_match])}/{len(best_match.matched_skills)}
                **Experience Match:** {'✅ Yes' if best_match.experience_match else '❌ No'}
                
                **Top 3 Job Recommendations:**
                """
                
                for i, job in enumerate(matching_result.job_matches[:3]):
                    summary += f"\n{i+1}. {job.job_title} - {job.overall_score:.1%} match"
                
                if matching_result.recommendations:
                    summary += f"\n\n**Recommendations:**\n"
                    for rec in matching_result.recommendations:
                        summary += f"• {rec}\n"
                
            else:
                summary = "No suitable job matches found. Consider expanding your search criteria or developing additional skills."
            
            state["messages"].append({
                "role": "assistant",
                "content": summary
            })
            
            state["workflow_status"] = "completed"
            
        except Exception as e:
            logger.error(f"Error in finalize results node: {str(e)}")
            state["error_message"] = str(e)
            state["workflow_status"] = "error"
        
        return state
    
    def _handle_error_node(self, state: WorkflowState) -> WorkflowState:
        """Node to handle errors"""
        error_msg = state.get("error_message", "Unknown error occurred")
        logger.error(f"Workflow error: {error_msg}")
        
        state["messages"].append({
            "role": "assistant",
            "content": f"❌ **Error occurred during processing:** {error_msg}\n\nPlease check your inputs and try again."
        })
        
        state["workflow_status"] = "failed"
        return state
    
    def _check_resume_analysis(self, state: WorkflowState) -> str:
        """Check if resume analysis was successful"""
        return "success" if state["workflow_status"] == "resume_analyzed" else "error"
    
    def _check_job_analysis(self, state: WorkflowState) -> str:
        """Check if job analysis was successful"""
        return "success" if state["workflow_status"] == "jobs_analyzed" else "error"
    
    def _check_matching_results(self, state: WorkflowState) -> str:
        """Check if matching was successful"""
        return "success" if state["workflow_status"] == "matching_complete" else "error"
    
    def run_matching_workflow(self, resume_file_path: str, job_descriptions: List[str]) -> Dict[str, Any]:
        """
        Run the complete resume-job matching workflow
        
        Args:
            resume_file_path: Path to the PDF resume file
            job_descriptions: List of job description texts
            
        Returns:
            Dictionary containing workflow results
        """
        try:
            # Initialize workflow state
            initial_state = WorkflowState(
                messages=[],
                resume_file_path=resume_file_path,
                job_descriptions=job_descriptions,
                resume_data={},
                job_data={},
                matching_results={},
                workflow_status="initialized",
                error_message=""
            )
            
            # Run the workflow
            logger.info("Starting resume-job matching workflow...")
            final_state = self.workflow.invoke(initial_state)
            
            # Prepare response
            response = {
                "status": final_state["workflow_status"],
                "messages": final_state["messages"],
                "resume_data": final_state.get("resume_data", {}),
                "job_data": final_state.get("job_data", {}),
                "matching_results": final_state.get("matching_results", {}),
                "error": final_state.get("error_message", "")
            }
            
            logger.info(f"Workflow completed with status: {final_state['workflow_status']}")
            return response
            
        except Exception as e:
            logger.error(f"Error running workflow: {str(e)}")
            return {
                "status": "failed",
                "error": str(e),
                "messages": [{"role": "assistant", "content": f"Workflow failed: {str(e)}"}]
            }
    
    def get_workflow_visualization(self) -> str:
        """Get a text representation of the workflow"""
        return """
        Resume-Job Matching Workflow:
        
        1. 📄 Analyze Resume
           ├─ Extract text from PDF
           ├─ Parse personal information
           ├─ Extract skills and experience
           └─ Structure resume data
        
        2. 💼 Analyze Job Descriptions  
           ├─ Parse job requirements
           ├─ Extract required skills
           ├─ Identify experience levels
           └─ Structure job data
        
        3. 🎯 Match Resume to Jobs
           ├─ Calculate skill matches
           ├─ Evaluate experience fit
           ├─ Compute overall scores
           └─ Rank opportunities
        
        4. 📊 Finalize Results
           ├─ Generate recommendations
           ├─ Create summary report
           └─ Return structured results
        """