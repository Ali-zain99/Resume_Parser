# job_description_agent.py - autogenerated template file
from langchain.agents import Tool, AgentExecutor, create_openai_functions_agent
from langchain.schema import SystemMessage, HumanMessage
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from typing import Dict, Any, List, Optional
import json
import logging
import re

from resume_job_matcher.models.data_models import JobDescription, AgentResponse, ExperienceLevel
from resume_job_matcher.utils.text_processor import TextProcessor
from resume_job_matcher.config.settings import settings

logger = logging.getLogger(__name__)

class JobDescriptionAgent:
    """Agent responsible for analyzing job descriptions and extracting requirements"""
    
    def __init__(self):
        self.llm = ChatOpenAI(
            model=settings.openai_model,
            temperature=settings.temperature,
            openai_api_key=settings.openai_api_key
        )
        self.text_processor = TextProcessor()
        self.agent_executor = self._create_agent()
    
    def _create_agent(self) -> AgentExecutor:
        """Create the job description analysis agent"""
        
        tools = [
            Tool(
                name="parse_job_content",
                description="Parse job description content and extract structured information",
                func=self._parse_job_content
            ),
            Tool(
                name="extract_job_skills",
                description="Extract required and preferred skills from job description",
                func=self._extract_job_skills
            ),
            Tool(
                name="identify_experience_level",
                description="Identify required experience level and years",
                func=self._identify_experience_level
            ),
            Tool(
                name="extract_responsibilities",
                description="Extract key responsibilities and duties",
                func=self._extract_responsibilities
            )
        ]
        
        prompt = ChatPromptTemplate.from_messages([
            SystemMessage(content="""You are a professional job description analyzer. Your tasks include:
            1. Parse job descriptions to extract key information like title, company, requirements
            2. Identify required and preferred skills with high accuracy
            3. Determine experience level and years of experience required
            4. Extract responsibilities, qualifications, and other important details
            5. Categorize and structure the information for matching purposes
            
            Be thorough and precise in your analysis. Distinguish between must-have and nice-to-have requirements.
            """),
            MessagesPlaceholder(variable_name="chat_history"),
            HumanMessage(content="{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad")
        ])
        
        agent = create_openai_functions_agent(self.llm, tools, prompt)
        return AgentExecutor(agent=agent, tools=tools, verbose=True)
    
    def _parse_job_content(self, job_text: str) -> str:
        """Parse job description content using LLM"""
        try:
            parsing_prompt = f"""
            Analyze the following job description and extract basic information:
            
            Job Description:
            {job_text}
            
            Provide a JSON response with:
            {{
                "title": "job title",
                "company": "company name",
                "location": "job location",
                "job_type": "full-time/part-time/contract/etc",
                "salary_range": "salary information if mentioned",
                "summary": "brief job summary"
            }}
            
            If any information is not found, use null for that field.
            """
            
            response = self.llm.invoke([HumanMessage(content=parsing_prompt)])
            return response.content
        except Exception as e:
            logger.error(f"Error parsing job content: {str(e)}")
            return json.dumps({"error": str(e)})
    
    def _extract_job_skills(self, job_text: str) -> str:
        """Extract required and preferred skills"""
        try:
            # First, use text processor to identify common skills
            basic_skills = self.text_processor.extract_skills(job_text)
            
            skills_prompt = f"""
            Analyze this job description and identify ALL required and preferred skills, technologies, and qualifications:
            
            Job Description:
            {job_text}
            
            Basic skills identified: {basic_skills}
            
            Provide a JSON response with:
            {{
                "required_skills": ["list of must-have skills"],
                "preferred_skills": ["list of nice-to-have skills"],
                "technical_skills": ["programming languages, frameworks, tools"],
                "soft_skills": ["communication, leadership, etc"],
                "certifications": ["required or preferred certifications"],
                "education_requirements": ["degree requirements"]
            }}
            
            Be very thorough and distinguish between required and preferred qualifications.
            """
            
            response = self.llm.invoke([HumanMessage(content=skills_prompt)])
            return response.content
        except Exception as e:
            logger.error(f"Error extracting job skills: {str(e)}")
            return json.dumps({"error": str(e)})
    
    def _identify_experience_level(self, job_text: str) -> str:
        """Identify experience level and years required"""
        try:
            # Use text processor to extract years
            years = self.text_processor.extract_years_of_experience(job_text)
            
            experience_prompt = f"""
            Analyze this job description to determine the required experience level:
            
            Job Description:
            {job_text}
            
            Years detected: {years}
            
            Provide a JSON response with:
            {{
                "years_required": {years if years else "null"},
                "experience_level": "entry|junior|mid|senior|lead|executive",
                "experience_details": "specific experience requirements",
                "seniority_indicators": ["keywords that indicate seniority level"]
            }}
            
            Consider keywords like 'senior', 'lead', 'principal', 'entry-level', 'junior', etc.
            """
            
            response = self.llm.invoke([HumanMessage(content=experience_prompt)])
            return response.content
        except Exception as e:
            logger.error(f"Error identifying experience level: {str(e)}")
            return json.dumps({"error": str(e)})
    
    def _extract_responsibilities(self, job_text: str) -> str:
        """Extract key responsibilities and qualifications"""
        try:
            responsibilities_prompt = f"""
            Extract key responsibilities and qualifications from this job description:
            
            Job Description:
            {job_text}
            
            Provide a JSON response with:
            {{
                "key_responsibilities": ["main duties and responsibilities"],
                "qualifications": ["education and certification requirements"],
                "day_to_day_tasks": ["typical daily activities"],
                "team_structure": "information about team and reporting structure",
                "growth_opportunities": "career growth and development opportunities"
            }}
            """
            
            response = self.llm.invoke([HumanMessage(content=responsibilities_prompt)])
            return response.content
        except Exception as e:
            logger.error(f"Error extracting responsibilities: {str(e)}")
            return json.dumps({"error": str(e)})
    
    def analyze_job_descriptions(self, job_texts: List[str]) -> AgentResponse:
        """
        Analyze multiple job descriptions
        
        Args:
            job_texts: List of job description texts
            
        Returns:
            AgentResponse with list of structured job data
        """
        try:
            if len(job_texts) < settings.min_job_descriptions:
                return AgentResponse(
                    agent_name=settings.job_agent_name,
                    success=False,
                    message=f"Minimum {settings.min_job_descriptions} job descriptions required",
                    error="Insufficient job descriptions"
                )
            
            analyzed_jobs = []
            
            for i, job_text in enumerate(job_texts[:settings.max_job_descriptions]):
                try:
                    # Use agent to analyze each job description
                    analysis_input = f"""
                    Please analyze this job description comprehensively:
                    
                    Job Description {i+1}:
                    {job_text}
                    
                    Extract all relevant information including title, company, skills, experience requirements, and responsibilities.
                    """
                    
                    result = self.agent_executor.invoke({
                        "input": analysis_input,
                        "chat_history": []
                    })
                    
                    # Parse the results into structured data
                    job_data = self._parse_job_output(job_text, result["output"], i+1)
                    analyzed_jobs.append(job_data.dict())
                    
                except Exception as e:
                    logger.error(f"Error analyzing job {i+1}: {str(e)}")
                    # Create basic job data for failed analysis
                    basic_job = JobDescription(
                        id=f"job_{i+1}",
                        title=f"Job {i+1}",
                        description="Analysis failed",
                        raw_text=job_text,
                        required_skills=self.text_processor.extract_skills(job_text)
                    )
                    analyzed_jobs.append(basic_job.dict())
            
            return AgentResponse(
                agent_name=settings.job_agent_name,
                success=True,
                message=f"Analyzed {len(analyzed_jobs)} job descriptions successfully",
                data={"jobs": analyzed_jobs}
            )
            
        except Exception as e:
            logger.error(f"Error in job description analysis: {str(e)}")
            return AgentResponse(
                agent_name=settings.job_agent_name,
                success=False,
                message="Failed to analyze job descriptions",
                error=str(e)
            )
    
    def _parse_job_output(self, raw_text: str, agent_output: str, job_id: int) -> JobDescription:
        """Parse agent output and create structured JobDescription"""
        try:
            # Extract JSON from agent output
            json_match = re.search(r'\{.*\}', agent_output, re.DOTALL)
            if json_match:
                parsed_data = json.loads(json_match.group())
            else:
                parsed_data = {}
            
            # Fallback to text processing
            basic_skills = self.text_processor.extract_skills(raw_text)
            years_exp = self.text_processor.extract_years_of_experience(raw_text)
            
            # Determine experience level from years
            experience_level = self._determine_experience_level(years_exp, raw_text)
            
            return JobDescription(
                id=f"job_{job_id}",
                title=parsed_data.get("title", f"Job {job_id}"),
                company=parsed_data.get("company"),
                location=parsed_data.get("location"),
                description=parsed_data.get("summary", raw_text[:500]),
                required_skills=parsed_data.get("required_skills", basic_skills) or basic_skills,
                preferred_skills=parsed_data.get("preferred_skills", []),
                experience_level=experience_level,
                years_required=years_exp,
                responsibilities=parsed_data.get("key_responsibilities", []),
                qualifications=parsed_data.get("qualifications", []),
                raw_text=raw_text
            )
            
        except Exception as e:
            logger.error(f"Error parsing job output: {str(e)}")
            # Return basic job data if parsing fails
            return JobDescription(
                id=f"job_{job_id}",
                title=f"Job {job_id}",
                description="Parsing failed",
                required_skills=self.text_processor.extract_skills(raw_text),
                years_required=self.text_processor.extract_years_of_experience(raw_text),
                raw_text=raw_text
            )
    
    def _determine_experience_level(self, years: Optional[int], job_text: str) -> Optional[ExperienceLevel]:
        """Determine experience level from years and job text"""
        job_text_lower = job_text.lower()
        
        # Check for explicit level keywords
        if any(keyword in job_text_lower for keyword in ['entry', 'entry-level', 'graduate', 'junior']):
            return ExperienceLevel.ENTRY
        elif any(keyword in job_text_lower for keyword in ['senior', 'sr.', 'lead']):
            return ExperienceLevel.SENIOR
        elif any(keyword in job_text_lower for keyword in ['principal', 'architect', 'director', 'manager']):
            return ExperienceLevel.LEAD
        elif any(keyword in job_text_lower for keyword in ['executive', 'vp', 'cto', 'ceo']):
            return ExperienceLevel.EXECUTIVE
        
        # Determine by years of experience
        if years:
            if years <= 2:
                return ExperienceLevel.ENTRY
            elif years <= 4:
                return ExperienceLevel.JUNIOR
            elif years <= 7:
                return ExperienceLevel.MID
            elif years <= 10:
                return ExperienceLevel.SENIOR
            else:
                return ExperienceLevel.LEAD
        
        return None