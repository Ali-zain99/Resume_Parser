# matching_agent.py - autogenerated template file

from langchain.agents import Tool, AgentExecutor, create_openai_functions_agent
from langchain.schema import SystemMessage, HumanMessage
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from typing import Dict, Any, List, Optional
import json
import logging
from datetime import datetime

from resume_job_matcher.models.data_models import (
    ResumeData, JobDescription, JobMatch, SkillMatch, 
    MatchingResult, AgentResponse
)
from resume_job_matcher.utils.text_processor import TextProcessor
from resume_job_matcher.config.settings import settings

logger = logging.getLogger(__name__)

class MatchingAgent:
    """Agent responsible for matching resumes with job descriptions"""
    
    def __init__(self):
        self.llm = ChatOpenAI(
            model=settings.openai_model,
            temperature=settings.temperature,
            openai_api_key=settings.openai_api_key
        )
        self.text_processor = TextProcessor()
        self.agent_executor = self._create_agent()
    
    def _create_agent(self) -> AgentExecutor:
        """Create the matching analysis agent"""
        
        tools = [
            Tool(
                name="calculate_skill_matches",
                description="Calculate skill matching scores between resume and job requirements",
                func=self._calculate_skill_matches
            ),
            Tool(
                name="evaluate_experience_match",
                description="Evaluate if candidate's experience matches job requirements",
                func=self._evaluate_experience_match
            ),
            Tool(
                name="assess_overall_compatibility",
                description="Assess overall compatibility between candidate and job",
                func=self._assess_overall_compatibility
            ),
            Tool(
                name="generate_recommendations",
                description="Generate personalized recommendations and insights",
                func=self._generate_recommendations
            )
        ]
        
        prompt = ChatPromptTemplate.from_messages([
            SystemMessage(content="""You are an expert career matching specialist. Your role is to:
            1. Accurately match candidate skills with job requirements
            2. Evaluate experience levels and compatibility
            3. Calculate comprehensive matching scores
            4. Provide detailed insights and recommendations
            5. Rank job opportunities based on fit and potential
            
            Consider both hard skills (technical) and soft skills, experience level, education, and career growth potential.
            Provide detailed explanations for your matching decisions.
            """),
            MessagesPlaceholder(variable_name="chat_history"),
            HumanMessage(content="{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad")
        ])
        
        agent = create_openai_functions_agent(self.llm, tools, prompt)
        return AgentExecutor(agent=agent, tools=tools, verbose=True)
    
    def _calculate_skill_matches(self, resume_skills: str, job_skills: str) -> str:
        """Calculate detailed skill matching scores"""
        try:
            resume_skills_list = json.loads(resume_skills) if isinstance(resume_skills, str) else resume_skills
            job_skills_list = json.loads(job_skills) if isinstance(job_skills, str) else job_skills
            
            skill_matches = []
            for job_skill in job_skills_list:
                best_match = None
                best_score = 0.0
                
                for resume_skill in resume_skills_list:
                    score = self.text_processor.calculate_skill_similarity(job_skill, resume_skill)
                    if score > best_score:
                        best_score = score
                        best_match = resume_skill
                
                skill_matches.append({
                    "skill": job_skill,
                    "is_match": best_score >= settings.similarity_threshold,
                    "similarity_score": best_score,
                    "resume_skill": best_match if best_score >= settings.similarity_threshold else None
                })
            
            return json.dumps(skill_matches)
        except Exception as e:
            logger.error(f"Error calculating skill matches: {str(e)}")
            return json.dumps({"error": str(e)})
    
    def _evaluate_experience_match(self, resume_exp: str, job_exp: str) -> str:
        """Evaluate experience level compatibility"""
        try:
            experience_prompt = f"""
            Evaluate the experience match between candidate and job requirements:
            
            Candidate Experience: {resume_exp}
            Job Requirements: {job_exp}
            
            Provide a JSON response with:
            {{
                "experience_match": true/false,
                "experience_gap": "description of any experience gaps",
                "experience_score": 0.0-1.0,
                "level_compatibility": "assessment of level match",
                "growth_potential": "assessment of growth opportunity"
            }}
            """
            
            response = self.llm.invoke([HumanMessage(content=experience_prompt)])
            return response.content
        except Exception as e:
            logger.error(f"Error evaluating experience match: {str(e)}")
            return json.dumps({"error": str(e)})
    
    def _assess_overall_compatibility(self, resume_data: str, job_data: str) -> str:
        """Assess overall compatibility between candidate and job"""
        try:
            compatibility_prompt = f"""
            Assess the overall compatibility between this candidate and job opportunity:
            
            Candidate Profile: {resume_data}
            Job Opportunity: {job_data}
            
            Consider:
            - Technical skill alignment
            - Experience level match
            - Career trajectory fit
            - Growth potential
            - Cultural fit indicators
            
            Provide a JSON response with:
            {{
                "overall_score": 0.0-1.0,
                "strengths": ["candidate strengths for this role"],
                "weaknesses": ["areas where candidate may lack"],
                "fit_assessment": "detailed compatibility assessment",
                "recommendation_level": "highly_recommended|recommended|potential_fit|not_recommended"
            }}
            """
            
            response = self.llm.invoke([HumanMessage(content=compatibility_prompt)])
            return response.content
        except Exception as e:
            logger.error(f"Error assessing compatibility: {str(e)}")
            return json.dumps({"error": str(e)})
    
    def _generate_recommendations(self, matching_results: str) -> str:
        """Generate personalized recommendations"""
        try:
            recommendations_prompt = f"""
            Based on the matching analysis, generate personalized recommendations:
            
            Matching Results: {matching_results}
            
            Provide actionable recommendations including:
            - Which jobs to prioritize and why
            - Skills to develop or highlight
            - Application strategy suggestions
            - Interview preparation tips
            - Career development advice
            
            Provide a JSON response with:
            {{
                "priority_jobs": ["job IDs in priority order"],
                "skill_development": ["skills to focus on developing"],
                "application_strategy": ["specific application advice"],
                "interview_prep": ["interview preparation suggestions"],
                "career_advice": ["longer-term career development advice"]
            }}
            """
            
            response = self.llm.invoke([HumanMessage(content=recommendations_prompt)])
            return response.content
        except Exception as e:
            logger.error(f"Error generating recommendations: {str(e)}")
            return json.dumps({"error": str(e)})
    
    def match_resume_to_jobs(self, resume_data: ResumeData, job_descriptions: List[JobDescription]) -> AgentResponse:
        """
        Main method to match resume against job descriptions
        
        Args:
            resume_data: Structured resume data
            job_descriptions: List of job descriptions to match against
            
        Returns:
            AgentResponse with matching results
        """
        try:
            job_matches = []
            
            for job in job_descriptions:
                try:
                    # Use agent to perform comprehensive matching
                    matching_input = f"""
                    Perform comprehensive matching analysis between this candidate and job opportunity:
                    
                    CANDIDATE PROFILE:
                    Name: {resume_data.name}
                    Skills: {resume_data.skills}
                    Experience: {resume_data.years_of_experience} years
                    Education: {resume_data.education}
                    Summary: {resume_data.summary}
                    
                    JOB OPPORTUNITY:
                    Title: {job.title}
                    Company: {job.company}
                    Required Skills: {job.required_skills}
                    Preferred Skills: {job.preferred_skills}
                    Experience Required: {job.years_required} years
                    Level: {job.experience_level}
                    Description: {job.description}
                    
                    Provide detailed matching analysis including skill alignment, experience fit, and overall compatibility.
                    """
                    
                    result = self.agent_executor.invoke({
                        "input": matching_input,
                        "chat_history": []
                    })
                    
                    # Process the matching results
                    job_match = self._process_job_match(resume_data, job, result["output"])
                    job_matches.append(job_match)
                    
                except Exception as e:
                    logger.error(f"Error matching job {job.id}: {str(e)}")
                    # Create basic match result for failed analysis
                    basic_match = JobMatch(
                        job_id=job.id,
                        job_title=job.title,
                        company=job.company,
                        overall_score=0.0,
                        recommendation_reason="Analysis failed"
                    )
                    job_matches.append(basic_match)
            
            # Rank job matches by overall score
            job_matches.sort(key=lambda x: x.overall_score, reverse=True)
            for i, match in enumerate(job_matches):
                match.ranking = i + 1
            
            # Create comprehensive matching result
            matching_result = MatchingResult(
                resume_summary=f"{resume_data.name} - {resume_data.years_of_experience} years experience",
                total_jobs_analyzed=len(job_matches),
                job_matches=job_matches,
                best_match=job_matches[0] if job_matches else None,
                analysis_timestamp=datetime.now().isoformat(),
                recommendations=self._generate_final_recommendations(resume_data, job_matches)
            )
            
            return AgentResponse(
                agent_name=settings.matching_agent_name,
                success=True,
                message=f"Successfully matched resume against {len(job_matches)} jobs",
                data=matching_result.dict()
            )
            
        except Exception as e:
            logger.error(f"Error in resume-job matching: {str(e)}")
            return AgentResponse(
                agent_name=settings.matching_agent_name,
                success=False,
                message="Failed to perform matching analysis",
                error=str(e)
            )
    
    def _process_job_match(self, resume_data: ResumeData, job: JobDescription, agent_output: str) -> JobMatch:
        """Process agent output into structured JobMatch"""
        try:
            # Calculate skill matches
            skill_matches = []
            missing_skills = []
            
            for job_skill in job.required_skills:
                best_match_score = 0.0
                best_resume_skill = None
                
                for resume_skill in resume_data.skills:
                    score = self.text_processor.calculate_skill_similarity(job_skill, resume_skill)
                    if score > best_match_score:
                        best_match_score = score
                        best_resume_skill = resume_skill
                
                is_match = best_match_score >= settings.similarity_threshold
                skill_match = SkillMatch(
                    skill=job_skill,
                    is_match=is_match,
                    similarity_score=best_match_score,
                    resume_skill=best_resume_skill if is_match else None
                )
                skill_matches.append(skill_match)
                
                if not is_match:
                    missing_skills.append(job_skill)
            
            # Calculate overall score
            matched_count = sum(1 for sm in skill_matches if sm.is_match)
            skill_score = matched_count / len(job.required_skills) if job.required_skills else 0.0
            
            # Experience match
            experience_match = self._check_experience_match(resume_data, job)
            
            # Education match (basic check)
            education_match = len(resume_data.education) > 0
            
            # Calculate weighted overall score
            overall_score = (skill_score * 0.6) + (0.3 if experience_match else 0.0) + (0.1 if education_match else 0.0)
            
            # Generate recommendation reason
            recommendation_reason = self._generate_recommendation_reason(
                skill_score, experience_match, matched_count, len(job.required_skills)
            )
            
            return JobMatch(
                job_id=job.id,
                job_title=job.title,
                company=job.company,
                overall_score=min(overall_score, 1.0),
                matched_skills=skill_matches,
                missing_skills=missing_skills,
                experience_match=experience_match,
                education_match=education_match,
                recommendation_reason=recommendation_reason
            )
            
        except Exception as e:
            logger.error(f"Error processing job match: {str(e)}")
            return JobMatch(
                job_id=job.id,
                job_title=job.title,
                company=job.company,
                overall_score=0.0,
                recommendation_reason="Processing error occurred"
            )
    
    def _check_experience_match(self, resume_data: ResumeData, job: JobDescription) -> bool:
        """Check if candidate's experience matches job requirements"""
        if not job.years_required or not resume_data.years_of_experience:
            return True  # No specific requirement or data available
        
        # Allow some flexibility (-1 year)
        return resume_data.years_of_experience >= (job.years_required - 1)
    
    def _generate_recommendation_reason(self, skill_score: float, experience_match: bool, 
                                      matched_skills: int, total_skills: int) -> str:
        """Generate human-readable recommendation reason"""
        if skill_score >= 0.8 and experience_match:
            return f"Excellent match! You have {matched_skills}/{total_skills} required skills and meet experience requirements."
        elif skill_score >= 0.6:
            return f"Good match! You have {matched_skills}/{total_skills} required skills. Consider developing missing skills."
        elif skill_score >= 0.4:
            return f"Potential fit. You have {matched_skills}/{total_skills} required skills. Significant skill development needed."
        else:
            return f"Limited match. You have {matched_skills}/{total_skills} required skills. Consider if this aligns with your career goals."
    
    def _generate_final_recommendations(self, resume_data: ResumeData, job_matches: List[JobMatch]) -> List[str]:
        """Generate final recommendations based on all matches"""
        recommendations = []
        
        if not job_matches:
            return ["No job matches found. Consider expanding your search criteria or developing additional skills."]
        
        best_match = job_matches[0]
        
        if best_match.overall_score >= 0.8:
            recommendations.append(f"Prioritize applying to {best_match.job_title} - it's an excellent match!")
        elif best_match.overall_score >= 0.6:
            recommendations.append(f"Focus on {best_match.job_title} and similar roles that match your skillset.")
        
        # Skill development recommendations
        all_missing_skills = set()
        for match in job_matches[:3]:  # Top 3 jobs
            all_missing_skills.update(match.missing_skills)
        
        if all_missing_skills:
            top_missing = list(all_missing_skills)[:3]
            recommendations.append(f"Consider developing these in-demand skills: {', '.join(top_missing)}")
        
        # Experience recommendations
        if resume_data.years_of_experience and resume_data.years_of_experience < 3:
            recommendations.append("Focus on entry-level and junior positions to build experience.")
        elif resume_data.years_of_experience and resume_data.years_of_experience > 7:
            recommendations.append("Consider senior and leadership positions that match your experience level.")
        
        return recommendations