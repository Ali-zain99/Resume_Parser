# main.py - autogenerated template file
import os
import sys
import logging
from typing import List, Dict, Any
import json
from pathlib import Path
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage
# Add project root to Python path
project_root = Path(__file__).parent
sys.path.append(str(project_root))

from config.settings import settings
from workflows.matching_workflow import ResumeJobMatchingWorkflow
from utils.pdf_reader import PDFReader

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('resume_matcher.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class ResumeJobMatcher:
    """Main application class for resume-job matching"""
    
    def __init__(self):
        self.workflow = ResumeJobMatchingWorkflow()
        self.pdf_reader = PDFReader()
    
    def validate_inputs(self, resume_path: str, job_descriptions: List[str]) -> Dict[str, Any]:
        """Validate input parameters"""
        validation_result = {
            "valid": True,
            "errors": [],
            "warnings": []
        }
        
        # Validate resume file
        if not os.path.exists(resume_path):
            validation_result["valid"] = False
            validation_result["errors"].append(f"Resume file not found: {resume_path}")
        elif not resume_path.lower().endswith('.pdf'):
            validation_result["valid"] = False
            validation_result["errors"].append("Resume file must be in PDF format")
        elif not self.pdf_reader.validate_pdf(resume_path):
            validation_result["valid"] = False
            validation_result["errors"].append("Invalid or corrupted PDF file")
        
        # Validate job descriptions
        if not job_descriptions:
            validation_result["valid"] = False
            validation_result["errors"].append("At least one job description is required")
        elif len(job_descriptions) < settings.min_job_descriptions:
            validation_result["valid"] = False
            validation_result["errors"].append(
                f"Minimum {settings.min_job_descriptions} job descriptions required, got {len(job_descriptions)}"
            )
        
        # Check job description content
        empty_jobs = [i for i, job in enumerate(job_descriptions) if not job.strip()]
        if empty_jobs:
            validation_result["warnings"].append(
                f"Empty job descriptions found at positions: {empty_jobs}"
            )
        
        # Check OpenAI API key
        if not settings.openai_api_key:
            validation_result["valid"] = False
            validation_result["errors"].append("OpenAI API key not configured")
        
        return validation_result
    
    def process_resume_job_matching(self, resume_path: str, job_descriptions: List[str]) -> Dict[str, Any]:
        """
        Process resume-job matching workflow
        
        Args:
            resume_path: Path to PDF resume file
            job_descriptions: List of job description texts
            
        Returns:
            Dictionary with matching results
        """
        try:
            logger.info("Starting resume-job matching process...")
            
            # Validate inputs
            validation = self.validate_inputs(resume_path, job_descriptions)
            if not validation["valid"]:
                return {
                    "success": False,
                    "error": "Input validation failed",
                    "validation_errors": validation["errors"],
                    "warnings": validation.get("warnings", [])
                }
            
            if validation.get("warnings"):
                logger.warning(f"Validation warnings: {validation['warnings']}")
            
            # Run the workflow
            result = self.workflow.run_matching_workflow(resume_path, job_descriptions)
            
            if result["status"] == "completed":
                logger.info("Resume-job matching completed successfully")
                return {
                    "success": True,
                    "status": result["status"],
                    "messages": result["messages"],
                    "matching_results": result["matching_results"],
                    "resume_data": result["resume_data"],
                    "job_data": result["job_data"],
                    "warnings": validation.get("warnings", [])
                }
            else:
                logger.error(f"Workflow failed with status: {result['status']}")
                return {
                    "success": False,
                    "status": result["status"],
                    "error": result.get("error", "Unknown workflow error"),
                    "messages": result.get("messages", [])
                }
                
        except Exception as e:
            logger.error(f"Error in resume-job matching process: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "status": "failed"
            }
    
    def print_results(self, results: Dict[str, Any]) -> None:
        """Print formatted results to console"""
        print("\n" + "="*80)
        print("ðŸŽ¯ RESUME-JOB MATCHING RESULTS")
        print("="*80)
        
        if not results["success"]:
            print(f"âŒ ERROR: {results.get('error', 'Unknown error')}")
            if "validation_errors" in results:
                print("\nValidation Errors:")
                for error in results["validation_errors"]:
                    print(f"  â€¢ {error}")
            return
        
        # Print warnings if any
        if results.get("warnings"):
            print("\nâš ï¸  WARNINGS:")
            for warning in results["warnings"]:
                print(f"  â€¢ {warning}")
        
        # Print messages from workflow
        if results.get("messages"):
            print("\nðŸ“‹ WORKFLOW MESSAGES:")
            for msg in results["messages"]:
                print(f"Debug: Message type: {type(msg)}, Attributes: {dir(msg)}")  # Debug line
                if isinstance(msg, (SystemMessage, HumanMessage, AIMessage)):
                    # Check for 'type' or other attributes instead of 'role'
                    msg_type = getattr(msg, 'type', 'unknown')  # Fallback to 'unknown' if no 'type'
                    if msg_type == "assistant" or (isinstance(msg, AIMessage) and 'assistant' in str(msg).lower()):
                        print(f"\n{msg.content}")
                    elif msg_type == "system":
                        print(f"\nSystem: {msg.content}")
                    elif msg_type == "human":
                        print(f"\nUser: {msg.content}")
                elif isinstance(msg, dict) and msg.get("role") == "assistant":
                    print(f"\n{msg['content']}")
        
        # Print detailed matching results
        if results.get("matching_results"):
            matching_data = results["matching_results"]
            print(f"\nðŸ“Š DETAILED ANALYSIS:")
            print(f"Total Jobs Analyzed: {matching_data.get('total_jobs_analyzed', 0)}")
            
            if matching_data.get("job_matches"):
                print(f"\nðŸ† TOP JOB MATCHES:")
                for i, job in enumerate(matching_data["job_matches"][:5], 1):
                    print(f"\n{i}. {job['job_title']}")
                    print(f"   Company: {job.get('company', 'Not specified')}")
                    print(f"   Match Score: {job['overall_score']:.1%}")
                    print(f"   Skills Matched: {len([s for s in job['matched_skills'] if s['is_match']])}/{len(job['matched_skills'])}")
                    print(f"   Experience Match: {'âœ…' if job['experience_match'] else 'âŒ'}")
                    if job.get('missing_skills'):
                        print(f"   Missing Skills: {', '.join(job['missing_skills'][:3])}")
        
        print("\n" + "="*80)
    def save_results_to_file(self, results: Dict[str, Any], output_path: str = "matching_results.json") -> bool:
        """Save results to JSON file"""
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, ensure_ascii=False)
            logger.info(f"Results saved to {output_path}")
            return True
        except Exception as e:
            logger.error(f"Error saving results to file: {str(e)}")
            return False

def main():
    """Main function for command-line usage"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Resume-Job Matching System")
    parser.add_argument("--resume", "-r", required=True, help="Path to PDF resume file")
    parser.add_argument("--jobs", "-j", required=True, nargs="+", help="Job description texts or file paths")
    parser.add_argument("--output", "-o", help="Output file path for results")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose logging")
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Initialize matcher
    matcher = ResumeJobMatcher()
    
    # Process job descriptions (support both text and file paths)
    job_descriptions = []
    for job_input in args.jobs:
        if os.path.exists(job_input):
            # Read from file
            try:
                with open(job_input, 'r', encoding='utf-8') as f:
                    job_descriptions.append(f.read())
            except Exception as e:
                logger.error(f"Error reading job file {job_input}: {str(e)}")
                sys.exit(1)
        else:
            # Treat as direct text input
            job_descriptions.append(job_input)
    
    # Run matching process
    results = matcher.process_resume_job_matching(args.resume, job_descriptions)
    
    # Print results
    matcher.print_results(results)
    
    # Save results if requested
    if args.output:
        matcher.save_results_to_file(results, args.output)
    
    # Exit with appropriate code
    sys.exit(0 if results["success"] else 1)

# Example usage function
def example_usage():
    """Example of how to use the system programmatically"""
    
    # Sample job descriptions
    job_descriptions = [
        """
        Senior Python Developer
        Company: TechCorp Inc.
        
        We are looking for a Senior Python Developer with 5+ years of experience.
        
        Required Skills:
        - Python programming
        - Django or Flask framework
        - PostgreSQL database
        - REST API development
        - Git version control
        
        Preferred Skills:
        - AWS cloud services
        - Docker containerization
        - React.js frontend
        - Agile methodologies
        
        Responsibilities:
        - Develop and maintain web applications
        - Design and implement APIs
        - Collaborate with frontend developers
        - Participate in code reviews
        """,
        
        """
        Data Scientist
        Company: DataTech Solutions
        
        We need a Data Scientist with 3+ years of experience in machine learning.
        
        Required Skills:
        - Python or R programming
        - Machine learning algorithms
        - Pandas, NumPy, Scikit-learn
        - SQL databases
        - Statistical analysis
        
        Preferred Skills:
        - TensorFlow or PyTorch
        - Tableau or Power BI
        - Big data technologies
        - Cloud platforms (AWS/Azure)
        
        Responsibilities:
        - Build predictive models
        - Analyze large datasets
        - Create data visualizations
        - Present findings to stakeholders
        """,
        
        """
        Full Stack Developer
        Company: StartupXYZ
        
        Looking for a Full Stack Developer with 2+ years of experience.
        
        Required Skills:
        - JavaScript/TypeScript
        - React.js or Angular
        - Node.js
        - MongoDB or PostgreSQL
        - HTML/CSS
        
        Preferred Skills:
        - Next.js framework
        - GraphQL
        - Docker
        - CI/CD pipelines
        
        Responsibilities:
        - Develop frontend and backend features
        - Design user interfaces
        - Optimize application performance
        - Work in agile environment
        """,
        
        """
        DevOps Engineer
        Company: CloudFirst Ltd.
        
        Seeking a DevOps Engineer with 4+ years of experience.
        
        Required Skills:
        - AWS or Azure cloud platforms
        - Docker and Kubernetes
        - CI/CD pipelines
        - Infrastructure as Code (Terraform)
        - Linux system administration
        
        Preferred Skills:
        - Monitoring tools (Prometheus, Grafana)
        - Configuration management (Ansible)
        - Scripting (Python, Bash)
        - Security best practices
        
        Responsibilities:
        - Manage cloud infrastructure
        - Automate deployment processes
        - Monitor system performance
        - Ensure security compliance
        """,
        
        """
        Machine Learning Engineer
        Company: AI Innovations
        
        We're hiring a Machine Learning Engineer with 3+ years of experience.
        
        Required Skills:
        - Python programming
        - TensorFlow or PyTorch
        - Machine learning algorithms
        - Model deployment and scaling
        - Data preprocessing
        
        Preferred Skills:
        - MLOps practices
        - Kubernetes
        - Apache Spark
        - Computer vision or NLP
        
        Responsibilities:
        - Design and implement ML models
        - Deploy models to production
        - Monitor model performance
        - Collaborate with data scientists
        """
    ]
    
    # Initialize matcher
    matcher = ResumeJobMatcher()
    
    # Replace with actual resume path
    resume_path = "sample_resume.pdf"
    
    print("ðŸš€ Running Resume-Job Matching Example...")
    print(f"ðŸ“„ Resume: {resume_path}")
    print(f"ðŸ’¼ Job Descriptions: {len(job_descriptions)} positions")
    
    # Run matching
    results = matcher.process_resume_job_matching(resume_path, job_descriptions)
    
    # Print results
    matcher.print_results(results)
    
    # Save results
    matcher.save_results_to_file(results, "example_results.json")

if __name__ == "__main__":
    # Check if running as script or example
    if len(sys.argv) > 1:
        main()
    else:
        print("Resume-Job Matching System")
        print("=" * 50)
        print("Usage:")
        print("  python main.py --resume path/to/resume.pdf --jobs 'job description 1' 'job description 2'")
        print("  python main.py -r resume.pdf -j job1.txt job2.txt -o results.json")
        print("\nOr modify the example_usage() function and run it directly.")
        print("\nFor example usage, uncomment the line below:")
        # example_usage()